
Haskell Notes




CHAPTER 1-2 :  STARTING OUT

Lazy Functions vs Strict functions (function’)

definition  - when a function doesn’t take parameters, that function is a definition

:  -  cons operator, adds something to the head of a list 
		
		ghci> 0:[1,2,3,4,5]
		[0,1,2,3,4,5]

++  -  concatonate operator, adds two lists together, both arguments must have brackets

        ghci> [1,2,3,4,5] ++ [4]
        
        ghci> [1,2,3,4,5] ++ [6,7,8,9,10]  
        [1,2,3,4,5,6,7,8,9,10]

        ghci> "hello" ++ " " ++ "world"  
        "hello world" 

&&  -  AND operator in Boolean

||  -  OR operator in Boolean

!!  -  get an element out of a list by index
		
		ghci> [1,2,3,4,5] !! 0
		5

head  -  function that takes a list and returns its head. The head of a list is its first element

        ghci> head [1,2,3,4,5]  
        1 

tail  -  function that takes a list and returns its tail 
      -  tail function chops off a list's head
      -  returns every element after the first

        ghci> tail [1,2,3,4,5]  
        [2,3,4,5]   

last -  function that takes a list and returns its last element

        ghci> last [1,2,3,4,5]
        5

init  -  function that takes a list and returns everything except its last element
        
        ghci> init [1,2,3,4,5]  
        [1,2,3,4] 

length  -  function that takes a list and returns its length

        ghci> length [1,2,3,4,5]
        5

null  -  function that checks if a list is empty
      -  If it is, it returns True, 
         otherwise it returns False

        ghci> null [1,2,3,4,5]
        False

        ghci> null []
        True

reverse  -  reverses a list

        ghci> reverse [1,2,3,4,5]
        [5,4,3,2,1]

take  -  takes a number and a list, extracts that many elements from the beginning of the list

        ghci> take 3 [1,2,3,4,5]
        [1,2,3]

        ghci> take 0 [1,2,3,4,5]
        []

        ghci> take 4 "Hello World"
        "Hell"


drop  -  takes a number and a list, drops the number of elements from the beginning of the list

        ghci> drop 3 [1,2,3,4,5]
        [4,5]

        ghci> drop 0 [1,2,3,4,5]
        []

        ghci> drop 4 "Hello World"
        "o World"

maximum  -  takes a list and returns the biggest element
        
        ghci> maximum [1,2,3,4,5]
        5

minimum  -  takes a list and returns the smallest element

        ghci> minimum [1,2,3,4,5]
        1

sum  -  takes a list of numbers and returns their sum

        ghci> sum [1,2,3,4,5]
        15

product  -  takes a list of numbers and returns their product

        ghci> product [1,2,3,4,5]
        120

elem  -  function that takes an element and a list of elements
      -  returns True if the thing is in the list 
      -  returns False if the thing is not in the list
      -  usually used as an infix function
		
		ghci> 1 ‘elem’ [1,2,3,4,5]
		True
		
		ghci> 6 ‘elem’ [1,2,3,4,5]
		False

                ghci> elem 1 [1,2,3,4,5]
                True

infix function  -  function called with infix notation
        + 
        - 
        *
        /
        ==
        :t
        ::

infix notation  -  putting the function name inbewtween two arguments
        
        5 + 6
        'a' == 'b'

prefix function  -  functions name followed by parameters

        ghci> sum 3 4
        7

** putting ''s around a prefix function allows it to be used as an infix function

        ghci> 3 'elem' [1,2,3]
        True

** putting ()s around an infix function allows it to be used as a prefix function

        ghci> (+) 2 2
        5

        ghci> (/10) 200
        20
    
range  -  makes a list that is an arithmetic sequence of elements
		
		ghci> [1..20]
		[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
		
		ghci> [a..m]
		"abcdefghijklm”
		
		ghci> [3,6..20]
		[3,6,9,12,15,18]

cycle  -  takes a list and cycles it into an infinite list.  used with take
		
		ghci> take 10 (cycle [1,2,3])  
		[1,2,3,1,2,3,1,2,3,1]  
		
		ghci> take 12 (cycle "LOL ")
		"LOL LOL LOL "   

repeat  -  takes and element and produces a list of just that element
        -  like cycling a list with only one element
		
                ghci> take 10 (repeat 5)
		[5,5,5,5,5,5,5,5,5,5]

replicate  -  replicate x times y

		ghci> replicate 3 10 
		[10,10,10]

list comprehensions  -  [ ‘output function’ | ‘condition’]

		ghci> [x*2 | x <- [1..10]]
		[2,4,6,8,10,12,14,16,18,20] 

		ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
		[10,11,12,14,16,17,18,20]  

		ghci> [ x | x <- [50..100], x `mod` 7 == 3]  
		[52,59,66,73,80,87,94]  

        ghci> let nouns = ["hobo","frog","pope"]  
        ghci> let adjectives = ["lazy","grouchy","scheming"]  
        ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]  
        ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",  
        "grouchy pope","scheming hobo","scheming frog","scheming pope"]

tuples  -  like lists, using () instead of []
        -  can contain multiple types of elements
        -  couples, triples, quadruples etc..
        -  no such thing as a singleton tuple
        -  functions must operate specifically on pairs, triples, etc

fst  -  takes a pair and returns its first component

        ghci> fst (a,b)
        a

snd  -  takes a pair and returns its second component

        ghci> snd (a,b)
        b

zip  -  function that takes two lists 
        then puts them together in one list by joining the elements into pairs
     -  zips together two lists, either in a tuple or with a binary function 

        ghci> zip [1,2,3,4,5] [a..z]
        [(1,a),(2,b),(3,c),(4,d),(5,e)]

        ghci> zip "Hello World" [1,2,3,4,5]
        [('H',1),('e',2),('l',3),('l',4),('o',5)]

binary function  -  function that takes two parameters




CHAPTER 3 : TYPES AND TYPECLASSES

:t  -  use before an expression to return the type signature

        ghci> :t 'a'
        'a' :: Char

        ghci> :t True
        Bool

        ghci> :t 2 == 2
        2 == 2 :: Bool

        ghci> :t ('a', 4 == 5)
        ('a', 4 ==5) :: (Char, Bool)

        ghci> :t fromIntegral
        fromIntegral :: (Integral a, Num b) => a -> b

::  -  "has type of"
        
        4 == 5 :: Bool
        [1,2,3] :: [int]

** Types are written in Captial Case

Int  -  type, represents an integer, bounded, max = 2147483647, min = -max

Integer  -  type, represents an integer, unbounded (Int is more efficient)

Float  -  type, real floating point with single precision

Double  -  type, real floating point with doubel precision

Bool  -  type, respresents an boolean, only values are True or False 

Char  -  type, represents a character, denoted by single quotes

Ordering  -  type, can be GT, LT, or EQ, (greater than, less than, equal to)

string - list of characters

        "Hello" == ["H","e","l","l","o"]

()  -  type representing an empty tuple 
        ** tuples are types 

type variable  -  variable to represent a type, any type

        ghci> :t zip
        zip :: [a] -> [b] -> [(a),(b)]

        ** a and b are the type variables
        ** a and b can be any type

typeclass  -  interface that defines some behavior

class constraint  -  everything written before the => symbol

        ghci> :t (==)  
        (==) :: (Eq a) => a -> a -> Bool

        ** Eq class is the class constraint

Eq  -  typeclass for types that support equality testing, uses == and /= functions
        types : (), Bool, Char, Int, Integer, Float, Double
        ghci> 

Ord  -  typeclass for types that have ordering, 
        types : (), Bool, Char, Int, Integer, Float, Double
        subset of Eq
        <, <=, >, >=

compare  -  function takes two Ord members of the same type and returns an ordering

        ghci> compare 5 2
        GT

        ghci> 2 'compare' 2
        EQ

        ghci> 2 'compare' 5
        LT

Show  -  typeclass for types that can be represented by strings
        types : (), Bool, Char, Int, Integer, Float, Double

show  -  function that takes a value whose type is a member of show and presents it to us as a string
      -  turns something into a string
        ghci> show True
        "True"

        ghci> show 3.141
        "3.141"

Read  -  typeclass for types that cannot be represented by strings
        types : ??

read  -  function that takes a string and returns a type which is a member of Read
      -  turns a string into another type

        ghci> read "True" || False
        True

        ghci> read "2" + 2
        4

        ghci> read "0":[1,2,3,4,5]
        [0,1,2,3,4,5]

type annotations  -  a way of explicitly saying what type an expression should be
                  -  adding :: to the end of an expression and then specifying a type
        ghci> read "5" :: Int  
        5  
        
        ghci> read "5" :: Float  
        5.0  
        
        ghci> (read "5" :: Float) * 4  
        20.0  
        
        ghci> read "[1,2,3,4,5]" :: [Int]  
        [1,2,3,4,5]  
        
        ghci> read "(3, 'b')" :: (Int, Char)  
        (3, 'b')  

Enum  -  typeclass for sequentially ordered types, types that can be enumerated
        types : (), Bool, Char, Ordering, Int, Integer, Float, Double

succ  -  function that takes anything that has a defined successor and returns that successor

        ghci> succ 1
        2

        ghci> succ 3.141
        4.141

        ghci> succ 'M'
        'N'
    
pred  -  function that takes anything that has a defined predecessor and returns that predecessor

        ghci> pred 10
        9

        ghci> pred 0
        -1

        ghci> pred 'z'
        'y'

Bounded  -  typeclass whose members have an upper and lower bound
        types : ??
                Bool (False, True)
                Int (-2147483647, 2147483647) 
                Char ('\NUL', '\1114111')
                Ordering (LT, GT)

** all tuples are part of Bounded, if the components are also in it

Num  -  typeclass whose members have the property of acting like numbers
        types : Int, Integer, Float, Double.
        subset of Show and Eq
    
Integral  -  typeclass whose members include integral numbers
        types : Int, Integer.
        subset of Enum

Floating  -  typeclass whose members include floating point numbers
        types : Float, Double.
        subset of Num

fromIntegral  -  function that converts from Integral to Num
 
        fromIntegral :: (Num b, Integral a) => a -> b

        ghci> fromIntegral (length [1,2,3,4,5]) + 3.2
        8.2




CHAPTER 4: SYNTAX IN FUNCTIONS

pattern matching

guards  -  way of testing if a property of a value is true or False
        -  indicated by pipes following a functions name and parameters
        -  usually indented to the right and lined up for several conditions
        -  if it evaluates to True, the corresponding function body is used
        -  if it evaluates to False, the corresponding function body is skipped
        -  last guard is usually called otherwise, is a catch all

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"  
            | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"  
            | otherwise                   = "You're a whale, congratulations!" 

where bindings -  keyword 'where' you can put on the line after the guards
               -  define names or functions
               -  where puts the expression first and the binding after

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | bmi <= 18.5 = "You're underweight, you emo, you!"  
            | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
            | otherwise                   = "You're a whale, congratulations!" 
            where bmi = weight / height ^ 2

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | bmi <= skinny = "You're underweight, you emo, you!"  
            | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | bmi <= fat    = "You're fat! Lose some weight, fatty!"  
            | otherwise     = "You're a whale, congratulations!"  
            where bmi = weight / height ^ 2  
                skinny = 18.5  
                normal = 25.0  
                fat = 30.0 

let bindings  -  keyword 'let' you can put expressions with
              -  let <bindings> in <expression>
              -  let puts the bindings first and the expression after

        ghci> 4 * (let a = 9 in a + 1) + 2  
        42

        ghci> [let factorial x = product [1..x] in (factorial 0, factorial 1, factorial 4, factorial 23)]
        [(1,1,24,25852016738884976640000)]
        
        ** you can bind several variables inline using semicolons
        ghci> (let a = 1; b = 2; c = 3 in a+b+c, let foo = "Hello "; bar = "World!" in foo ++ bar)
        (6,"Hello World!")

        ** you can put let binding inside list comprehensions
        ** omit the 'in' part of the let binding
        calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
        calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2] 


case expression  -  expressions

        ** syntax for case expressions:
        case <expression> of <pattern> -> result  
                             <pattern> -> result  
                             <pattern> -> result  

        head' :: [a] -> a  
        head' xs = case xs of [] -> error "No head for empty lists!"  
                            (x:_) -> x  

        describeList :: [a] -> String  
        describeList xs = "The list is " ++ case xs of [] -> "empty."  
                                                    [x] -> "a singleton list."   
                                                    xs -> "a longer list." 




CHAPTER 5 : RECURSION

recursion  -  way of defining functions in which the function is applied inside its own definition

        fibonacci :: (Integral a) => a -> a
        fibonacci 0 = 0
        fibonacci 1 = 1
        fibonacci n = fibonacci (n - 2) * fibonacci (n - 1)

edge condition/case  -  element/s in a recursive definition defined non-recursively
                     -  for lists, the edge case is most often the empty list
                     -  for trees, the edge case is usually a node that doesn't have any children
                     -  think of when a recursive solution doesn't apply, see if you can use that as an edge case

        factorial :: (Integral a) => a -> a
-->     factorial 0 = 1
        factorial n = n * factorial (n - 1)

** no for loops or while loops in Haskell

maximum  -  function that takes a list of things that can me ordered and returns the biggest of them
 
        maximum' :: (Ord a) => [a] -> a  
        maximum' [] = error "maximum of empty list"  
        maximum' [x] = x  
        maximum' (x:xs)   
                | x > maxTail = x  
                | otherwise = maxTail  
                where maxTail = maximum' xs 

functions implemented using recursion:

        replicate' :: (Num i, Ord i) => i -> a -> [a]  
        replicate' n x  
                | n <= 0    = []  
                | otherwise = x:replicate' (n-1) x  

        take' :: (Num i, Ord i) => i -> [a] -> [a]  
        take' n _  
                | n <= 0 = []  
        take' _ [] = []  
        take' n (x:xs) = x : take' (n-1) xs 

        reverse' :: [a] -> [a]  
        reverse' [] = []  
        reverse' (x:xs) = reverse' xs ++ [x] 

        repeat' :: a -> [a]
        repeat; x = x:repeat' x

        zip' :: [a] -> [b] -> [(a,b)]  
        zip' _ [] = []  
        zip' [] _ = []  
        zip' (x:xs) (y:ys) = (x,y):zip' xs ys  

        elem' :: (Eq a) => a -> [a] -> Bool  
        elem' a [] = False  
        elem' a (x:xs)  
                | a == x    = True  
                | otherwise = a `elem'` xs   

quicksort  -  function which sorts a list in ascending order

        quicksort :: (Ord a) => [a] -> [a]  
        quicksort [] = []  
        quicksort (x:xs) =   
        let smallerSorted = quicksort [a | a <- xs, a <= x]  
                biggerSorted = quicksort [a | a <- xs, a > x]  
        in  smallerSorted ++ [x] ++ biggerSorted 

type signature  -  a line describing the type of a variable

        ghci> :t (*)
        (*) :: Num a => a -> a -> a

        ghci> :t fromIntegral
        fromIntegral :: (Integral a, Num b) => a -> b



CHAPTER 6 : HIGHER ORDER FUNCTIONS

higher order function  -  a function that 
                       -  take functions as parameters OR
                       -  return functions as return values

** every function in Haskell only takes one parameter technically

curried function  -  function taking in multiple arguments as a tuple as its argument
                  -  takes one parameter and returns a function with one less parameter in its argument

partially applied function  -  supplying fewer arguments than expected to a function that takes multiple arguments
                            -  get back a function that expects the remaining results
                            -  get back a function that takes as many paramaters as we left out

        ghci> max 4 5
        5

        ghci> (max 4) 5

function application  -  using a function on something
                      -  function x, applying function to x
                      -  x is applied as an argument to f
                      -  putting a space between two things is function application

sections  -  infix funcitions can be partially applied by using sections
          -  to section an infix function, surround it with parentheses and suppy a parameter to one skipped

        ghci> (/10) 200
        20

        ghci> (10/) 200
        5.0e-2

map  -  takes a function and a list
     -  applies the function to every element in the list, producing a new list

        ghci> map (+2) [1,2,3,4,5]
        [3,4,5,6,7]

        ghci> map (replicate 3) [1,2,3,4,5]
        [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]

predicate  -  function that returns a boolean value

filter  -  function that takes a predicate and a list
        -  applies the predicate to the list and returns a list of elements that satisfy the predicate
        -  doesn't work on infinite lists  (takeWhile does though)

        ghci> filter (>3) [1,2,3,4,5]
        [4,5]

        ghci> filter even [1,2,3,4,5]
        [2,4]

takeWhile  -  fucntion that takes a predicate and a list
           -  starting at the beginning of the list, returns elements while the predicate holds true
           -  stops at first element where predicate doesn't hold
           -  works on infinite lists

        ghci> takeWhile (<=4) [1,2,3,4,5]
        [1,2,3,4]

Lambdas  -  anonymous functions used only once
         -  normally made to pass to a higher order function
         -  uses '\' then parameters, dseparated by spaces
         -  usually surrounded by parentheses

        ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  
        [3,8,9,8,7]

fold  -  takes a binary function, a starting value (accumulator), and a list
      -  binary function itself calls 2 parameters, the accumulator and an element in the list
      -  only the accumulator remains

fold1  -  function that folds up the list from the left side
       -  binary function calls the accumulator and the head of the list
       -  creates a new accumulator value, which is called by the binary function along with the next element in the list

foldr  -  function that folds up the list from the right side
       -  binary function calls the accumulator and last of the list
       -  creates a new accumulator value, which is called by the binary function along with the next element in the list

foldll  -  works like foldl, but you don't need to provide an explicit starting value
        -  assumes the first element of the list is the starting value (head)

foldrl  -  works like foldr, but you don't need to provide an explicit starting value
        -  assumes the last element of the list is the starting value (last)

scanl  -  function that works like foldl, only it returns a list instead of a single value
       -  reports all intermediate accumulator states in the form of a list
       -  final result will be the last element of the resulting list (last)

scanr  -  function that works like foldr, only it returns a list instead of a single value
       -  reports all intermediate accumulator states in the form of a list
       -  final result will be the first element of the resulting list (head)

scanll  -  works like scanl, but you don't need to provide an explicit starting value
        -  assumes the last element of the list is the starting value (last)

scanrl  -  works like scanr, but you don't need to provide an explicit starting value
        -  assumes the first element of the list is the starting value (head)

function application  -  the $ function, also konwn as function application
                      -  function application with a space is left associative
                      -  function application with $ is right associative
                      -  function application with $ is the lowest precedence (infixr 0)
                      -  function application with a space has a high precedence
                      -  low precedence means that $ is sort of the equivalent of writing a ( and then writing ) on the far right side of the expression

        ghci> :t ($)
        ($) :: (a -> b) -> a -> b
        
        f $ x = f x

        f $ g $ h x = f (g (h(x)))
                
        f g h x = ((f g) h) x

        sqrt (1 + 2 + 3 + 4 + 5) = sqrt $ 1 + 2 + 3 + 4 + 5 

Function Composition  -  composing two functions produces a new function 
                      -  (f o g) = f(g(x))
                      -  is right associativem allowing you to compose many functions at a time
                      -  f (f (z x)) = (f . g . z) x

        ghci> :t (.)
        (.) :: (b -> c) -> (a -> b) -> a -> c

        f . g = \x -> f (g x)

Point Free Style  -  currying allows us to remove the variable from both sides of a function
                  -  common use of function composition

        sum' :: (Num a) => [a] -> a     
        sum' xs = foldl (+) 0 xs
        sum' = foldl (+) 0

        fn x = ceiling (negate (tan (cos (max 50 x)))) 
        fn  = ceiling . negate . tan . cos . max 50  




CHAPTER 7: MODULES

Hakell module  -  a collection of related functions, types and typeclasses

Haskell program  -  collection of modules 
                 -  where the main module loads up the other modules 
                 -  and then uses the functions defined in them to do something
        
Haskell standard library  -  split into modules 
                          -  each module contains functions and types that are related nad serve a common purpose

Prelude Module  -  the most important Haskell module
                -  imported by default
                -  contains most commonly used functions
                -  all functions, types and typeclasses so far

**  Import modules, which export functions to the global namespace  **                

import <module name>  -  syntax for importing modules in Haskell script
                      -  one script can import several modules
                      -  once you import a module, all of the functions exported become available in the global namespace
                      -  global namespace means you can call a function from anywhere in the script
        
        ghci> import Data.List 

                      -  you can also load up modules with :m +
                      
        ghci> :m + Data.List

        ghci> :m + Data.List Data.Map Data.set

                      -  you can also load up specific functions from modules
        
        ghci> :m + Data.List (nub, sort)

                      -  you can also import all of the funcitions from a module except a few select ones
                      -  useful when importing modules which export multiple functions of the same name
                      -  multiple functions referenced from different modules causes name clashing

        ghci> :m + Data.List hiding (nub)

nub  -  function that takes a list and weeds out duplicate elements

        length . nub => \xs -> length (nub xs)

import qualified <module name>  -  importing a module such that each function exported by that module is referenced
                                -  to call a function from a qualified import, you have to write <module name>.function
                
        ghci>  import qualified Data.Map
        ghci>  Data.Map.filter (>3) [1,2,3,4,5]
        [4,5]

        ghci>  import qualified Data.Map as M
        ghci>  M.filter (>3) [1,2,3,4,5]
        [4,5]



Data.List  -  module providing useful functions for dealing with lists
           -  don't have to import Data.List via qualified import because it doesn't clash with any Prelude names


map  -  takes a function and a list
     -  applies the function to every element in the list, producing a new list

        ghci> map (+2) [1,2,3,4,5]
        [3,4,5,6,7]

        ghci> map (replicate 3) [1,2,3,4,5]
        [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]

predicate  -  function that returns a boolean value

filter  -  function that takes a predicate and a list
        -  applies the predicate to the list and returns a list of elements that satisfy the predicate
        -  doesn't work on infinite lists  (takeWhile does though)

        ghci> filter (>3) [1,2,3,4,5]
        [4,5]

        ghci> filter even [1,2,3,4,5]
        [2,4]

intersperse  -  function that takes an element and a list 
             -  then puts that element inbetween each pair of elements in the list
        
        ghci> intersperse '.' "USMC"
        "U.S.M.C"

        ghci> intersperse ' ' "MOMMY"
        "M O M M Y"

intercalate  -  function that takes a list of lists and a list
                then inserts that list in between all of those lists and then flattens the result

        ghci> intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]  
        [1,2,3,0,0,0,4,5,6,0,0,0,7,8,9] 
        
        ghci> intercalate " " ["hey", "there", "guys"]
        "hey there guys"

transpose  -  function that takes a list of lists and transposes it
           -  looking at a list of lists as a 2D matrix, 
              the columns become the rows and the rows become the columns

        ghci> transpose [[1,2,3],[4,5,6][7,8,9]]
        [[1,4,7],[2,5,8],[3,6,9]]

        ghci> ["hey","there","guys"]  
        ["htg","ehu","yey","rs","e"]  

        ** adding polynomials
        [0, 3, 5, 9]  : 3x^2 + 5x + 9
        [8, 5, 1, -1] : 8x^3 + 5x^2 + x - 1  
        [10, 0, 0, 9] : 10x^3 + 9 

        ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]  
        [18,8,6,17]  

foldl'  -  stricter version of foldl
        -  updates the accumulator value more often, avoiding stack overflow

foldr'  -  stricter version of foldr
        -  updates the accumulator value more often, avoiding stack overflow

concat  -  flattens a list of lists into just a list of elements

        ghci> concat ["moo", "cow", "4755"]
        "moocow4755"

        ghci> concat [[1,2,3].[4,5,6],[7,8,9]]
        [1,2,3,4,5,6,7,8,9]

concatMap  -  function that first maps a function to a list 
              then concatenates the list with concat

        ghci> concatMap (replicate 5) [1,2,3,4,5]
        [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5]

and  -  takes a list of boolean values 
        and returns True only if all of the values in the list are True

        ghci> and $ map (>4) [5,6,7,8]
        True

        ghci> and $ map (>3) [1,2,3,4,5]
        False

or  -  takes a list of boolean values
       and returns True if any of the values in the list are True

        ghci> or $ map (>3) [1,2,3,4,5]
        True

any  -  function that takes a predicate 
        and then checks if any of the elements satisfy the predicate
        
        ghci> any (==4) [2,3,5,6,1,4]  
        True  

        ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
        True  

all  -  function that takes a predicate 
        and then checks if all of the elements satisfy the predicate
        
        ghci> all (>4) [6,9,10]  
        True

        ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
        False  

iterate  -  function that takes a function and a starting value 
         -  applies the function to the starting value
            then applies the funciton to that result
            then applies the function to that result again, et cetera
         -  returns all the results in the form of an infinite list

        ghci> take 10 $ iterate (*2) 1
        [1,2,4,8,16,32,64,128,256,512]

        ghci> take 3 $ iterate (++ "haha") "haha"
        ["haha","hahahahaha","hahahahahaha"]

splitAt  -  function that takes a number and a list
            then splits the list at that many elements
            returning the resulting two lists in a tuple

        ghci> splitAt 3 "Hello World!"
        ("Hel","lo World!")

        ghci> splitAt 100 "Hello World!"
        ("Hello World!"," ")

takeWhile  -  function that takes elements from a list while the predicate is true
              then when the predicate isn't satisfied, it's cut off, 
              returning all the first elements in the list that did satisfy the predicate 

        ghci> takeWhile (<4) [1,2,3,4,5]
        [1,2,3]

        ghci> takeWhile (/=' ') "Hello World"
        "Hello"

dropWhile  -  function that takes elements from a list while the predicate is True
              then when the predicate isn't satisfied, 
              it returns the rest of the list 

        ghci> dropWhile (/=' ') "This is a sentence"  
        " is a sentence"  
        
        ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]  
        [3,4,5,4,3,2,1]

span  -  function that takes elements from a list while the predicate is True
         then when the predicate isn't satisfied, it returns a pair of lists
      -  the first list contains everything that did satisfy the predicate (what takewhile returns)
      -  the second list contains the part of the list that would have been dropped (what dropWhile returns)

        ghci> ghci> span (/=3) [1,2,3,4,5]  
        ([1,2],[3,4,5]) 

break  -  function that takes elements from a list while the predicate is False
          then when the predicate is satisfied, it returns a pair of lists
       -  the first list contains everything that didn't satisfy the predicate
       -  the second list contains the rest of the list 
        
        ghci> break (==4) [1,2,3,4,5,6,7]  
        ([1,2,3],[4,5,6,7])

sort  -  function that simply sorts a list
      -  the type of elements in the list has to be part of the Ord typeclass

        ghci> sort [8,5,3,2,1,6,4,2]  
        [1,2,2,3,4,5,6,8]  
        
        ghci> sort "This will be sorted soon"  
        "    Tbdeehiillnooorssstw"

group  -  function that takes a list 
          and groups adjacent elements into sublists if they are equal
        
        ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
        [[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]  

inits  -  function that takes a list and returns everything except its last element
       -  function is recursively applied until there's nothing left

        ghci> inits "Hello!"
        ["","H","He","Hel","Hell","Hello","Hello!"]

tails  -  function that takes a list and returns everything except its first element
       -  function is recursively applied until there's nothing left

        ghci> tails "Hello!"
        ["Hello!","ello!","llo!","lo!","o!","!",""]

isInfixOf  -  function that searches for a sublist whithin a list 
              returns True if the sublist we're looking for is somewhere inside the target list
        
        ghci> "cat" `isInfixOf` "im a cat burglar"  
        True  
        ghci> "Cat" `isInfixOf` "im a cat burglar"  
        False

isPrefixOf  -  function that searches for a sublist at the beginning of a list

        ghci> "hey" `isPrefixOf` "hey there!"  
        True  
        ghci> "hey" `isPrefixOf` "oh hey there!"  
        False  

isSuffixOf  -  function that searches for a sublist at the end of a list

        ghci> "there!" `isSuffixOf` "oh hey there!"  
        True  
        ghci> "there!" `isSuffixOf` "oh hey there"  
        False  

elem  -  function that checks if an element is in a list

nonElem  -  function that checks if an element is not in a list

partition  -  function that takes a list and a predicate and returns a pair of lists
           -  first list in the results are elements that satisfy the predicate
           -  second list in the results are elements that don't satisfy the predicate

        ghci> partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
        ("BOBMORGAN","sidneyeddy") 

        ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]  
        ([5,6,7],[1,3,3,2,1,0,3])

Maybe value  -  algebraic data type 
             -  can be either no elements or a single element
             -  can either be Nothing or Just something

find  -  function that takes a list and predicate 
      -  returns the first element that satisfies the predicate
      -  element is wrapped in a Maybe value

        ghci> find (>4) [1,2,3,4,5,6]  
        Just 5  

        ghci> find (>9) [1,2,3,4,5,6]  
        Nothing  
        
        ghci> :t find  
        find :: (a -> Bool) -> [a] -> Maybe a 

elemIndex  -  function that takes an element and a list of elements
           -  maybe returns the index of the element we're looking for
           
        ghci> :t elemIndex  
        elemIndex :: (Eq a) => a -> [a] -> Maybe Int  
        
        ghci> 4 `elemIndex` [1,2,3,4,5]  
        Just 3  
        
        ghci> 10 `elemIndex` [1,2,3,4,5]  
        Nothing 

elemIndeces  -  function that takes an element and a list of elements
             -  returns a list of indices of the element we're looking for
             -  don't need the maybe data type, because Nothing can be represented as an empty list
        
        ghci> ' ' `elemIndices` "Where are the spaces?"  
        [5,9,13]  

findIndex  -  function that takes an element and a list of elements
           -  returns the index of the first element that satisfies the predicate
        
        ghci> findIndex (==4) [1,2,3,4,5]  
        Just 3
        
        ghci> findIndex (==7) [1,2,3,4,5]  
        Nothing 

findIndices  -  function that takes an element and a list of elements
             -  returns a list of indices of all elements that satisfy the predicate

        ghci> findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"  
        [0,6,10,14]

zip3  -  function that takes three lists 
         then puts them together in one list by joining the elements into pairs


zip4...zip7  -  same as zip three but taking 4, 5, 6, or 7 lists

        ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
        [(2,2,5,2),(3,2,5,2),(3,2,3,2)]

zipWith3  - 
        
        ghci> zipWith3 (\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]  
        [7,9,8] 

zipWith4...zipWith7  -  

lines  -  function that takes a string
          returns every line of that string in a separate list
       -  useful for dealing with files or input from somewhere

       ghci> lines "first line\nsecond line\nthird line"  
        ["first line","second line","third line"]  

unlines  -  function that takes a list of strings and joins them together using a '\n'
         -  inverse function of lines

        ghci> unlines ["first line", "second line", "third line"]  
        "first line\nsecond line\nthird line\n"

words  -  function that splits a line of text into words

        ghci> words "hey these are the words in this sentence"  
        ["hey","these","are","the","words","in","this","sentence"]  
        
        ghci> words "hey these           are    the words in this\nsentence"

unwords  -  function that joins a list of words into a line of text

        ghci> unwords ["hey","there","mate"]  
        "hey there mate" 

delete  -  function that takes an element and a list
           and deletes the first occurence of that element in the list

\\  -  the list difference function 
    -  for every element in the right-hand list, 
       it removes a matching element from the left one

        ghci> [1..10] \\ [2,5,9]  
        [1,3,4,6,7,8,10]  
        
        ghci> "Im a big baby" \\ "big"  
        "Im a  baby"  

union  -  function that takes two lists
          and returns the union of the two lists

        ghci> [1..7] `union` [5..10]  
        [1,2,3,4,5,6,7,8,9,10]  
        
        ghci> "hey man" `union` "man what's up"  
        "hey manwt'sup"  

intersect  -  function that takes two lists
              and returns a list of elements that are found in both lists

        ghci> [1..7] `intersect` [5..10]  
        [5,6,7]  

insert  -  function that takes an element and a list of elements that can be sorted
           and inserts the element into the list of elements in order
        -  inserts the element into the last position where it's still <= the next element in the list
        -  starts at the beginning of the list and checks every element 
           until it finds one equal to or greater than the element we're inserting
           and then inserts it before the element

        ghci> insert 4 [1,2,3,5,6,7]  
        [1,2,3,4,5,6,7]  
       
        ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']  
        "abcdefghijklmnopqrstuvwxyz"  
       
        ghci> insert 3 [1,2,4,3,2,1]  
        [1,2,3,4,3,2,1]

 genericLength  -  
 genericTake  -  
 genericDrop  -  
 genericSplitAt  -  
 genericIndex  -  
 genericReplicate  -  functions in Data.List 
                      that are generic equivalents for take, drop, splitAt, !! and replicate
                   -  take any type that's part of the Integral or Num typeclasses
                   -  generic counterparts take and return Int

nubBy  -
deleteBy  -
intersectBy  -
groupBy  -  functions in Data.List
            that are the generic equivalents of nub, delete, union, intersect and group
         -  take an equality function and then compare them by using that equality function
         -  generic equivalents use == to test for equality

on  -  function that transforms two inputs and combines the outputs
       (+) `on` f) x y = f x + f y
    -  or runs the binary function b on the results of applyin unary function u to two arguments x and y
       on b u x y
    -  typically used with sortBy
        on :: (b -> b -> c) -> (a -> b) -> a -> a -> c  
        
        f `on` g = \x y -> f (g x) (g y)

        (==) 'on' (> 0) = \x y -> (x > 0) == (y > 0)

sortBy  -
insertBy  -
maximumBy  -
minimumBy  -  functions in Data.List
              that are the generic equivalents of sort, insert, maximum and minimum
           -  take a function that determines when one element is greater, smaller, or equal to another element



Data.Char  -  module that exports functions that deal with characters
           -  helpful when filtering and mapping over strings 
           -  strings are just lists of characters
           -  exports predicates over characters
           -  functions that take a character and tell us wheather some assumption is True or False

isControl  -  predicate that checks whether a character is a control characters
        
isSpace  -  predicate that checks whether a charcter is a white-space character

white-space character  -  spaces, tab characters, newlines et cetera

isLower  -  predicate that checks whether a character is lower case

isUpper  -  predicate that checks whether a character is upper case

isAlpha  -  predicate that checks whether a character is a letter

isAlphaNum  -  predicate that checks whether a character is a letter or a number

isPrint  -  predicate that checks whether a character is printable
         -  control characters are not printable par examplf

isDigit  -  predicate that checks whether a character is a digit

isOctDigit  -  predicate that checks whether a character is an octal digit

isHexDigit  -  predicate that checks whether a character is a hex digit

isLetter  -  predicate that checks whether a character is a letter
          -  GeneralCategorys:
             UppercaseLetter
             LowercaseLetter
             TitlecaseLetter
             ModifierLetter
             OtherLetter

isMark  -  predicate that checks whether a character is a Unicode mark character
        -  Unicode mark characters are characters that combine with preceding letters to form latters with accents
        -  GeneralCategorys:
           NonSpacingMark
           SpacingCombiningMark
           EnclosingMark

isNumber  -  predicate that checks whether a character is numeric
          -  GeneralCategorys:
             Decimal number
             Letter number
             Other number

isPunctuation  -  predicate that checks whether a character is punctuation
               -  GeneralCategorys
                  ConnectorPunctuation
                  DashPunctuation
                  OpenPunctuation
                  ClosePunctuation
                  InitialQuote
                  FinalQuote
                  OtherPunctuation

isSymbol  -  predicate that checks whether a character is a symbol
          -  GeneralCategorys:
             MathSymbol
             CurrencySymbol
             ModifierSymbol
             OtherSymbol

isSeparator  -  predicate that checks whether a character is a Unicode space or separator
             -  GeneralCategorys:
                Space
                Line Separator
                ParagraphSeparator

isAscii  -  predicate that checks whether a character falls into the first 128 characters of the Unicode character set

isLatin1  -  predicate that checks whether a character falls into the first 256 characters of Unicode

isAsciiUpper  -  predicate that checks whether a character is Ascii and upper case

isAsciiLower  -  predicate that checks whether a character is Ascii and lower case

**  All of these predicates have the type signature Char -> Bool  **
**  Use this predicates in combination with functions from Data.List **

        ghci> all isAlphaNum "bobby283"  
        True  

        ghci> all isAlphaNum "eddy the fish!"  
        False  

GeneralCategory  -  type that is an enumeration
                 -  returns few possible categories that a character can fall into
                 -  there are 31 GeneralCategorys 
                    all of which are listed above in the predicate definitions

        generalCategory :: Char -> GeneralCategory

toUpper  -  function that converts a character to upper case
         -  spaces, numbers etc remain unchanged

toLower  -  function that converts a character to lower-case

toTitle  -  function that converts a character to title case
         -  title case is the same as upper case for most characters

digitToInt  -  function that converts a character to an Int 
            -  character must be in the ranges '0'..'9', 'a'..'f', 'A'..'F'

inToDigit  -  function that takes an Int in the ramge of 0..15  
              and converts it to a lower-case character
           -  inverse function of digitToInt

ord  -  function that converts characters to their corresponding numbers 

        ghci> ord 'a'
        97

chr  -  function that converts numbers to their corresponding characters

        ghci> chr 97
        'a'



Data.Map  -  module that offeres association lists that are faster
             because they're internally implemented with trees
          -  intended to be imported qualified, to avoid name clashes with Prelude functions, e.g
        
        ghci> import qualified Data.Map as Map

association lists  -  lists that are used to store key-value pairs where ordering doesn't matter 
                   -  also known as 'dictionaries'
         

        phoneBook =   
                [("betty","555-2938")  
                ,("bonnie","452-2928")  
                ,("patsy","493-2928")  
                ,("lucille","205-2928")  
                ,("wendy","939-8282")  
                ,("penny","853-2492")  
                ]  

fromList  -  function that takes an association list in the form of a list
             and returns a map with the same associations
          -  if there are duplicate keys in the original list,
             the duplicates are discarded

        Map.fromList :: (Ord k) => [(k, v)] -> Map.Map k v  

empty  -  function that represents an empty map
       -  takes no arguments
       -  just returns an empty map

        ghci> Map.empty  
        fromList []

insert  -  function that takes a key, a value and a map
           and returns a new map that's just like the old one,
           only with the key and value inserted

null  -  function that checks if a map is empty

        ghci> Map.null Map.empty  
        True  
        
        ghci> Map.null $ Map.fromList [(2,3),(5,5)]  
        False 

size  -  function that reports the size of a map

        ghci> Map.size Map.empty  
        0  
        
        ghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]  
        5 

singelton  -  function that takes a key and a value
              and creates a map that has exactly one mapping

        ghci> Map.singleton 3 9  
        fromList [(3,9)] 

        ghci> Map.insert 5 9 $ Map.singleton 3 9  
        fromList [(3,9),(5,9)]  

lookup  -  function that works like Data.List lookup
           only it operates on maps
        -  returns Just something if it finds something for the key
           returns Nothing if it doesn't

member  -  a predicate that takes a key and a map
           and reports whether the key is in the map or not

        ghci> Map.member 3 $ Map.fromlist [(3,4),(4,3),6,9)]
        True

        ghci> Map.member 3 $ Map.fromList [(2,5),(4,5)]
        False

predicate  -  function that returns a boolean value

map  -  takes a function and a list
     -  applies the function to every element in the list, producing a new list

        ghci> map (+2) [1,2,3,4,5]
        [3,4,5,6,7]

        ghci> map (replicate 3) [1,2,3,4,5]
        [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]

filter  -  function that takes a predicate and a list
        -  applies the predicate to the list and returns a list of elements that satisfy the predicate
        -  doesn't work on infinite lists  (takeWhile does though)

        ghci> filter (>3) [1,2,3,4,5]
        [4,5]

toList  -  function that is the inverse of fromList

        ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3  
        [(4,3),(9,2)]

keys  -  function that returns list of keys
      -  equivalent of map snd . Map.toList

elems  -  function that returns list of values 
       -  equivalent of map fst  . Map.toList

fromListWith 
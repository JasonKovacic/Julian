
Haskell Notes


CHAPTER 1-2 :  STARTING OUT

Lazy Functions vs Strict functions (function’)

definition  - when a function doesn’t take parameters, that function is a definition

:  -  cons operator, adds something to the head of a list 
		
		ghci> 0:[1,2,3,4,5]
		[0,1,2,3,4,5]

++  -  concatonate operator, adds two lists together, both arguments must have brackets

        ghci> [1,2,3,4,5] ++ [4]
        
        ghci> [1,2,3,4,5] ++ [6,7,8,9,10]  
        [1,2,3,4,5,6,7,8,9,10]

        ghci> "hello" ++ " " ++ "world"  
        "hello world" 

&&  -  AND operator in Boolean

||  -  OR operator in Boolean

!!  -  get an element out of a list by index
		
		ghci> [1,2,3,4,5] !! 0
		5

head  -  takes a list and returns its head. The head of a list is its first element

        ghci> head [1,2,3,4,5]  
        1 

tail  -  takes a list and returns its tail. In other words, it chops off a list's head

        ghci> tail [1,2,3,4,5]  
        [2,3,4,5]   

last -  takes a list and returns its last element

        ghci> last [1,2,3,4,5]
        5

init  -  takes a list and returns everything except its last element
        
        ghci> init [1,2,3,4,5]  
        [1,2,3,4] 

length  -  takes a list and returns its length

        ghci> length [1,2,3,4,5]
        5

null  -  checks if a list is empty. If it is, it returns True, otherwise it returns False. 

        ghci> null [1,2,3,4,5]
        False

        ghci> null []
        True

reverse  -  reverses a list

        ghci> reverse [1,2,3,4,5]
        [5,4,3,2,1]

take  -  takes a number and a list, extracts that many elements from the beginning of the list

        ghci> take 3 [1,2,3,4,5]
        [1,2,3]

        ghci> take 0 [1,2,3,4,5]
        []

        ghci> take 4 "Hello World"
        "Hell"


drop  -  takes a number and a list, drops the number of elements from the beginning of the list

        ghci> drop 3 [1,2,3,4,5]
        [4,5]

        ghci> drop 0 [1,2,3,4,5]
        []

        ghci> drop 4 "Hello World"
        "o World"

maximum  -  takes a list and returns the biggest element
        
        ghci> maximum [1,2,3,4,5]
        5

minimum  -  takes a list and returns the smallest element

        ghci> minimum [1,2,3,4,5]
        1

sum  -  takes a list of numbers and returns their sum

        ghci> sum [1,2,3,4,5]
        15

product  -  takes a list of numbers and returns their product

        ghci> product [1,2,3,4,5]
        120

elem  -  takes a thing and a list of things and returns True if the thing is in the list 
    False if the thing is not in the list.  Usually used as an infix function
		
		ghci>  1 ‘elem’ [1,2,3,4,5]
		True
		
		ghci> 6 ‘elem’ [1,2,3,4,5]
		False

infix function  -  function called with infix notation
        + 
        - 
        *
        /
        ==
        :t
        ::

infix notation  -  putting the function name inbewtween two arguments
        
        5 + 6
        'a' == 'b'

prefix function  -  functions name followed by parameters

        ghci> sum 3 4
        7


** putting ''s around a prefix function allows it to be used as an infix function

        ghci> 3 'elem' [1,2,3]
        True

** putting ()s around an infix function allows it to be used as a prefix function

        ghci> (+) 2 2
        5
    
range  -  makes a list that is an arithmetic sequence of elements
		
		ghci> [1..20]
		[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
		
		ghci> [a..m]
		"abcdefghijklm”
		
		ghci> [3,6..20]
		[3,6,9,12,15,18]

cycle  -  takes a list and cycles it into an infinite list.  used with take
		
		ghci> take 10 (cycle [1,2,3])  
		[1,2,3,1,2,3,1,2,3,1]  
		
		ghci> take 12 (cycle "LOL ")
		"LOL LOL LOL "   

repeat  -   takes and element and produces a list of just that element
		
		ghci> take 10 (repeat 5)
		[5,5,5,5,5,5,5,5,5,5]

replicate  -  replicate x times y

		ghci> replicate 3 10 
		[10,10,10]

list comprehensions  -  [ ‘output function’ | ‘condition’]

		ghci> [x*2 | x <- [1..10]]
		[2,4,6,8,10,12,14,16,18,20] 

		ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
		[10,11,12,14,16,17,18,20]  

		ghci> [ x | x <- [50..100], x `mod` 7 == 3]  
		[52,59,66,73,80,87,94]  

        ghci> let nouns = ["hobo","frog","pope"]  
        ghci> let adjectives = ["lazy","grouchy","scheming"]  
        ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]  
        ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",  
        "grouchy pope","scheming hobo","scheming frog","scheming pope"]

tuples  -  like lists, using () instead of []
        -  can contain multiple types of elements
        -  couples, triples, quadruples etc..
        -  no such thing as a singleton tuple
        -  functions must operate specifically on pairs, triples, etc

fst  -  takes a pair and returns its first component

        ghci> fst (a,b)
        a

snd  -  takes a pair and returns its second component

        ghci> snd (a,b)
        b

zip  -  takes two lists and puts them together in one list by joining the elements into pairs

        ghci> zip [1,2,3,4,5] [a..z]
        [(1,a),(2,b),(3,c),(4,d),(5,e)]

        ghci> zip "Hello World" [1,2,3,4,5]
        [('H',1),('e',2),('l',3),('l',4),('o',5)]

CHAPTER 3 : TYPES AND TYPECLASSES

:t  -  use before an expression to return the type/types

        ghci> :t 'a'
        'a' :: Char

        ghci> :t True
        Bool

        ghci> :t 2 == 2
        2 == 2 :: Bool

        ghci> :t ('a', 4 == 5)
        ('a', 4 ==5) :: (Char, Bool)

::  -  "has type of"
        
        4 == 5 :: Bool
        [1,2,3] :: [int]

** Types are written in Captial Case

Int  -  type, represents an integer, bounded, max = 2147483647, min = -max

Integer  -  type, represents an integer, unbounded

Float  -  type, real floating point with single precision

Double  -  type, real floating point with doubel precision

Bool  -  type, respresents an boolean, only values are True or False 

Char  -  type, represents a character, denoted by single quotes

Ordering  -  type, can be GT, LT, or EQ, (greater than, less than, equal to)

string - list of characters

        "Hello" == ["H","e","l","l","o"]

()  -  type representing an empty tuple 
        ** tuples are types 

type variable  -  variable to represent a type, any type

        ghci> :t zip
        zip :: [a] -> [b] -> [(a),(b)]

        ** a and b are the type variables

typeclass  -  interface that defines some behavior

class constraint  -  everything written before the -> symbol

        ghci> :t (==)  
        (==) :: (Eq a) => a -> a -> Bool

        ** Eq class is the class constraint

Eq  -  typeclass for types that support equality testing, uses == and /= functions
        types : (), Bool, Char, Int, Integer, Float, Double
        ghci> 

Ord  -  typeclass for types that have ordering, 
        types : (), Bool, Char, Int, Integer, Float, Double
        subset of Eq
        <, <=, >, >=

compare  -  function takes two Ord members of the same type and returns an ordering

        ghci> compare 5 2
        GT

        ghci> 2 'compare' 2
        EQ

        ghci> 2 'compare' 5
        LT

Show  -  typeclass for types that can be represented by strings
        types : (), Bool, Char, Int, Integer, Float, Double

show  -  function that takes a value whose type is a member of show and presents it to us as a string

        ghci> show True
        "True"

        ghci> show 3.141
        "3.141"

Read  -  typeclass for types that cannot be represented by strings
        types : ????????

read  -  function that takes a string and returns a type which is a member of Read

        ghci> read "True" || False
        True

        ghci> read "2" + 2
        4

        ghci> read "0":[1,2,3,4,5]
        [0,1,2,3,4,5]

type annotations  -  a way of explicitly saying what type an expression should be

        ghci> read "5" :: Int  
        5  
        
        ghci> read "5" :: Float  
        5.0  
        
        ghci> (read "5" :: Float) * 4  
        20.0  
        
        ghci> read "[1,2,3,4,5]" :: [Int]  
        [1,2,3,4,5]  
        
        ghci> read "(3, 'b')" :: (Int, Char)  
        (3, 'b')  

Enum  -  typeclass for sequentially ordered types, types that can be enumerated
        types : (), Bool, Char, Ordering, Int, Integer, Float, Double

succ  -  function that takes anything that has a defined successor and returns that successor

        ghci> succ 1
        2

        ghci> succ 3.141
        4.141
    
pred  -  function that takes anything that has a defined predecessor and returns that predecessor

        ghci> pred 10
        9

        ghci> pred 0
        -1

Bounded  -  typeclass whose members have an upper and lower bound
        types : ?????????
        ** all tuples are part of Bounded, if the components are also in it

Num  -  typeclass whose members have the property of acting like numbers
        types : Int, Integer, Float, Double
        subset of Show and Eq
    
Integral  -  typeclass whose members include integral numbers
        types : Int, Integer
        subset of Num

Floating  -  typeclass whose members include floating point numbers
        types : Float, Double
        subset of Num

fromIntegral  -  function that converts from Integral to Num
 
        ghci> fromIntegral :: (Num b, Integral a) => a -> b

        ghci> Example needed

CHAPTER 4: SYNTAX IN FUNCTIONS

pattern matching

guards  -  way of testing if a property of a value is true or False
        -  indicated by pipes folling a functions name and parameters
        -  usually indented to the right and lined up for several conditions
        -  if it evaluates to True, the corresponding function body is used
        -  if it evaluates to False, the corresponding function body is skipped
        -  last guard is usually called otherwise, is a catch all

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"  
            | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"  
            | otherwise                   = "You're a whale, congratulations!" 

where bindings -  keyword 'where' you can put on the line after the guards
               -  define names or functions
               -  where puts the expression first and the binding after

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | bmi <= 18.5 = "You're underweight, you emo, you!"  
            | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
            | otherwise                   = "You're a whale, congratulations!" 
            where bmi = weight / height ^ 2

        bmiTell :: (RealFloat a) => a -> a -> String  
        bmiTell weight height  
            | bmi <= skinny = "You're underweight, you emo, you!"  
            | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"  
            | bmi <= fat    = "You're fat! Lose some weight, fatty!"  
            | otherwise     = "You're a whale, congratulations!"  
            where bmi = weight / height ^ 2  
                skinny = 18.5  
                normal = 25.0  
                fat = 30.0 

let bindings  -  keyword 'let' you can put expressions with
              -  let <bindings> in <expression>
              -  let puts the bindings first and the expression after

        ghci> 4 * (let a = 9 in a + 1) + 2  
        42

        ghci> [let factorial x = product [1..x] in (factorial 0, factorial 1, factorial 4, factorial 23)]
        [(1,1,24,25852016738884976640000)]
        
        ** you can bind several variables inline using semicolons
        ghci> (let a = 1; b = 2; c = 3 in a+b+c, let foo = "Hello "; bar = "World!" in foo ++ bar)
        (6,"Hello World!")

        ** you can put let binding inside list comprehensions
        ** omit the 'in' part of the let binding
        calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
        calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2] 


case expression  -  expressions

        ** syntax for case expressions:
        case <expression> of <pattern> -> result  
                             <pattern> -> result  
                             <pattern> -> result  

        head' :: [a] -> a  
        head' xs = case xs of [] -> error "No head for empty lists!"  
                            (x:_) -> x  

        describeList :: [a] -> String  
        describeList xs = "The list is " ++ case xs of [] -> "empty."  
                                                    [x] -> "a singleton list."   
                                                    xs -> "a longer list." 

CHAPTER 5 : RECURSION

recursion  -  way of defining functions in which the function is applied inside its own definition

        fibonacci :: (Integral a) => a -> a
        fibonacci 0 = 0
        fibonacci 1 = 1
        fibonacci n = fibonacci (n - 2) * fibonacci (n - 1)

edge condition/case  -  element/s in a recursive definition defined non-recursively
                     -  for lists, the edge case is most often the empty list
                     -  for trees, the edge case is usually a node that doesn't have any children
                     -  think of when a recursive solution doesn't apply, see if you can use that as an edge case

        factorial :: (Integral a) => a -> a
-->     factorial 0 = 1
        factorial n = n * factorial (n - 1)

** no for loops or while loops in Haskell

maximum  -  function that takes a list of things that can me ordered and returns the biggest of them
 
        maximum' :: (Ord a) => [a] -> a  
        maximum' [] = error "maximum of empty list"  
        maximum' [x] = x  
        maximum' (x:xs)   
                | x > maxTail = x  
                | otherwise = maxTail  
                where maxTail = maximum' xs 

functions implemented using recursion:

        replicate' :: (Num i, Ord i) => i -> a -> [a]  
        replicate' n x  
                | n <= 0    = []  
                | otherwise = x:replicate' (n-1) x  

        take' :: (Num i, Ord i) => i -> [a] -> [a]  
        take' n _  
                | n <= 0 = []  
        take' _ [] = []  
        take' n (x:xs) = x : take' (n-1) xs 

        reverse' :: [a] -> [a]  
        reverse' [] = []  
        reverse' (x:xs) = reverse' xs ++ [x] 

        repeat' :: a -> [a]
        repeat; x = x:repeat' x

        zip' :: [a] -> [b] -> [(a,b)]  
        zip' _ [] = []  
        zip' [] _ = []  
        zip' (x:xs) (y:ys) = (x,y):zip' xs ys  

        elem' :: (Eq a) => a -> [a] -> Bool  
        elem' a [] = False  
        elem' a (x:xs)  
                | a == x    = True  
                | otherwise = a `elem'` xs   

quicksort  -  function which sorts a list in ascending order

        quicksort :: (Ord a) => [a] -> [a]  
        quicksort [] = []  
        quicksort (x:xs) =   
        let smallerSorted = quicksort [a | a <- xs, a <= x]  
                biggerSorted = quicksort [a | a <- xs, a > x]  
        in  smallerSorted ++ [x] ++ biggerSorted 

type signature  -  ????

CHAPTER 6 : HIGHER ORDER FUNCTIONS

higher order function  -  a function that 
                       -  take functions as parameters OR
                       -  return functions as return values

** every function in Haskell only takes one parameter technically

curried function  -  

Haskell Notes

Lazy Functions vs Strict functions (function’)

definition  - when a function doesn’t take parameters, that function is a definition

:  -  cons operator, adds something to the head of a list 
		
		ghci> 0:[1,2,3,4,5]
		[0,1,2,3,4,5]

++  -  concatonate operator, adds two lists together, both arguments must have brackets

        ghci> [1,2,3,4,5] ++ [4]
        
        ghci> [1,2,3,4,5] ++ [6,7,8,9,10]  
        [1,2,3,4,5,6,7,8,9,10]

        ghci> "hello" ++ " " ++ "world"  
        "hello world" 

&&  -  AND operator in Boolean

||  -  OR operator in Boolean

!!  -  get an element out of a list by index
		
		ghci> [1,2,3,4,5] !! 0
		5

head  -  takes a list and returns its head. The head of a list is its first element

        ghci> head [1,2,3,4,5]  
        1 

tail  -  takes a list and returns its tail. In other words, it chops off a list's head

        ghci> tail [1,2,3,4,5]  
        [2,3,4,5]   

last -  takes a list and returns its last element

        ghci> last [1,2,3,4,5]
        5

init  -  takes a list and returns everything except its last element
        
        ghci> init [1,2,3,4,5]  
        [1,2,3,4] 

length  -  takes a list and returns its length

        ghci> length [1,2,3,4,5]
        5

null  -  checks if a list is empty. If it is, it returns True, otherwise it returns False. 

        ghci> null [1,2,3,4,5]
        False

        ghci> null []
        True

reverse  -  reverses a list

        ghci> reverse [1,2,3,4,5]
        [5,4,3,2,1]

take  -  takes a number and a list, extracts that many elements from the beginning of the list

        ghci> take 3 [1,2,3,4,5]
        [1,2,3]

        ghci> take 0 [1,2,3,4,5]
        []

        ghci> take 4 "Hello World"
        "Hell"


drop  -  takes a number and a list, drops the number of elements from the beginning of the list

        ghci> drop 3 [1,2,3,4,5]
        [4,5]

        ghci> drop 0 [1,2,3,4,5]
        []

        ghci> drop 4 "Hello World"
        "o World"

maximum  -  takes a list and returns the biggest element
        
        ghci> maximum [1,2,3,4,5]
        5

minimum  -  takes a list and returns the smallest element

        ghci> minimum [1,2,3,4,5]
        1

sum  -  takes a list of numbers and returns their sum

        ghci> sum [1,2,3,4,5]
        15

product  -  takes a list of numbers and returns their product

        ghci> product [1,2,3,4,5]
        120

elem  -  takes a thing and a list of things and returns True if the thing is in the list 
    False if the thing is not in the list.  Usually used as an infix function
		
		ghci>  1 ‘elem’ [1,2,3,4,5]
		True
		
		ghci> 6 ‘elem’ [1,2,3,4,5]
		False

infix function  -  function called with infix notation
        + 
        - 
        *
        /
        ==

infix notation  -  putting the function name inbewtween two arguments
        
        5 + 6
        'a' == 'b'

prefix function  -  functions name followed by parameters

        ghci> sum 3 4
        7

        ghci> 
** putting ''s around a prefix function allows it to be used as an infix function

        ghci> 3 'elem' [1,2,3]
        True

** putting ()s around an infix function allows it to be used as a prefix function

        ghci> (+) 2 2
        5
    
range  -  makes a list that is an arithmetic sequence of elements
		
		ghci> [1..20]
		[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
		
		ghci> [a..m]
		"abcdefghijklm”
		
		ghci> [3,6..20]
		[3,6,9,12,15,18]

cycle  -  takes a list and cycles it into an infinite list.  used with take
		
		ghci> take 10 (cycle [1,2,3])  
		[1,2,3,1,2,3,1,2,3,1]  
		
		ghci> take 12 (cycle "LOL ")
		"LOL LOL LOL "   

repeat  -   takes and element and produces a list of just that element
		
		ghci> take 10 (repeat 5)
		[5,5,5,5,5,5,5,5,5,5]

replicate  -  replicate x times y

		ghci> replicate 3 10 
		[10,10,10]

list comprehensions  -  [ ‘output function’ | ‘condition’]

		ghci> [x*2 | x <- [1..10]]
		[2,4,6,8,10,12,14,16,18,20] 

		ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
		[10,11,12,14,16,17,18,20]  

		ghci> [ x | x <- [50..100], x `mod` 7 == 3]  
		[52,59,66,73,80,87,94]  

        ghci> let nouns = ["hobo","frog","pope"]  
        ghci> let adjectives = ["lazy","grouchy","scheming"]  
        ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]  
        ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",  
        "grouchy pope","scheming hobo","scheming frog","scheming pope"]

tuples  -  like lists, using () instead of []
        -  can contain multiple types of elements
        -  couples, triples, quadruples etc..
        -  no such thing as a singleton tuple
        -  functions must operate specifically on pairs, triples, etc

fst  -  takes a pair and returns its first component

snd  -  takes a pair and returns its second component

zip  -  takes two lists and puts them together in one list by joining the elements into pairs

:t  -  use before and expression to return the types

        ghci> :t 'a'
        'a' :: Char

        ghci> :t 4 == 5
        4 == 5 :: Bool
    
::  -  "has type of"
        
        4 == 5 :: Bool
        [1,2,3] :: [int]


